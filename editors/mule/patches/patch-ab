$NetBSD: patch-ab,v 1.2 2005/12/01 18:13:24 wiz Exp $

--- src/unexelf.c.orig	1994-10-21 05:21:00.000000000 +0100
+++ src/unexelf.c
@@ -1,19 +1,22 @@
 /* Copyright (C) 1985, 1986, 1987, 1988, 1990, 1992
    Free Software Foundation, Inc.
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2, or (at your option)
-    any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+This file is part of GNU Emacs.
+
+GNU Emacs is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Emacs is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Emacs; see the file COPYING.  If not, write to
+the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
 
 In other words, you are welcome to use, share and improve this program.
 You are forbidden to forbid anyone else to use, share and improve
@@ -30,14 +33,14 @@ what you give them.   Help stamp out sof
  * Modified heavily since then.
  *
  * Synopsis:
- *	unexec (new_name, a_name, data_start, bss_start, entry_address)
- *	char *new_name, *a_name;
+ *	unexec (new_name, old_name, data_start, bss_start, entry_address)
+ *	char *new_name, *old_name;
  *	unsigned data_start, bss_start, entry_address;
  *
  * Takes a snapshot of the program and makes an a.out format file in the
  * file named by the string argument new_name.
- * If a_name is non-NULL, the symbol table will be taken from the given file.
- * On some machines, an existing a_name file is required.
+ * If old_name is non-NULL, the symbol table will be taken from the given file.
+ * On some machines, an existing old_name file is required.
  *
  * The boundaries within the a.out file may be adjusted with the data_start
  * and bss_start arguments.  Either or both may be given as 0 for defaults.
@@ -98,64 +101,64 @@ temacs:
         Link    Info    Adralgn      Entsize
 
 [1]     1       2       0x80480d4    0xd4         0x13          .interp
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [2]     5       2       0x80480e8    0xe8         0x388         .hash
-        3       0       0x4          0x4          
+        3       0       0x4          0x4
 
 [3]     11      2       0x8048470    0x470        0x7f0         .dynsym
-        4       1       0x4          0x10         
+        4       1       0x4          0x10
 
 [4]     3       2       0x8048c60    0xc60        0x3ad         .dynstr
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [5]     9       2       0x8049010    0x1010       0x338         .rel.plt
-        3       7       0x4          0x8          
+        3       7       0x4          0x8
 
 [6]     1       6       0x8049348    0x1348       0x3           .init
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [7]     1       6       0x804934c    0x134c       0x680         .plt
-        0       0       0x4          0x4          
+        0       0       0x4          0x4
 
 [8]     1       6       0x80499cc    0x19cc       0x3c56f       .text
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [9]     1       6       0x8085f3c    0x3df3c      0x3           .fini
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [10]    1       2       0x8085f40    0x3df40      0x69c         .rodata
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [11]    1       2       0x80865dc    0x3e5dc      0xd51         .rodata1
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [12]    1       3       0x8088330    0x3f330      0x20afc       .data
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [13]    1       3       0x80a8e2c    0x5fe2c      0x89d         .data1
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [14]    1       3       0x80a96cc    0x606cc      0x1a8         .got
-        0       0       0x4          0x4          
+        0       0       0x4          0x4
 
 [15]    6       3       0x80a9874    0x60874      0x80          .dynamic
-        4       0       0x4          0x8          
+        4       0       0x4          0x8
 
 [16]    8       3       0x80a98f4    0x608f4      0x449c        .bss
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [17]    2       0       0            0x608f4      0x9b90        .symtab
-        18      371     0x4          0x10         
+        18      371     0x4          0x10
 
 [18]    3       0       0            0x6a484      0x8526        .strtab
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [19]    3       0       0            0x729aa      0x93          .shstrtab
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [20]    1       0       0            0x72a3d      0x68b7        .comment
-        0       0       0x1          0            
+        0       0       0x1          0
 
 raid:/nfs/raid/src/dist-18.56/src> dump -h xemacs
 
@@ -166,67 +169,67 @@ xemacs:
         Link    Info    Adralgn      Entsize
 
 [1]     1       2       0x80480d4    0xd4         0x13          .interp
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [2]     5       2       0x80480e8    0xe8         0x388         .hash
-        3       0       0x4          0x4          
+        3       0       0x4          0x4
 
 [3]     11      2       0x8048470    0x470        0x7f0         .dynsym
-        4       1       0x4          0x10         
+        4       1       0x4          0x10
 
 [4]     3       2       0x8048c60    0xc60        0x3ad         .dynstr
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [5]     9       2       0x8049010    0x1010       0x338         .rel.plt
-        3       7       0x4          0x8          
+        3       7       0x4          0x8
 
 [6]     1       6       0x8049348    0x1348       0x3           .init
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [7]     1       6       0x804934c    0x134c       0x680         .plt
-        0       0       0x4          0x4          
+        0       0       0x4          0x4
 
 [8]     1       6       0x80499cc    0x19cc       0x3c56f       .text
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [9]     1       6       0x8085f3c    0x3df3c      0x3           .fini
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [10]    1       2       0x8085f40    0x3df40      0x69c         .rodata
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [11]    1       2       0x80865dc    0x3e5dc      0xd51         .rodata1
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [12]    1       3       0x8088330    0x3f330      0x20afc       .data
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [13]    1       3       0x80a8e2c    0x5fe2c      0x89d         .data1
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [14]    1       3       0x80a96cc    0x606cc      0x1a8         .got
-        0       0       0x4          0x4          
+        0       0       0x4          0x4
 
 [15]    6       3       0x80a9874    0x60874      0x80          .dynamic
-        4       0       0x4          0x8          
+        4       0       0x4          0x8
 
 [16]    8       3       0x80c6800    0x7d800      0             .bss
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [17]    2       0       0            0x7d800      0x9b90        .symtab
-        18      371     0x4          0x10         
+        18      371     0x4          0x10
 
 [18]    3       0       0            0x87390      0x8526        .strtab
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [19]    3       0       0            0x8f8b6      0x93          .shstrtab
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [20]    1       0       0            0x8f949      0x68b7        .comment
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [21]    1       3       0x80a98f4    0x608f4      0x1cf0c       .data
-        0       0       0x4          0            
+        0       0       0x4          0
 
  * This is an example of how the file header is changed.  "Shoff" is
  * the section header offset within the file.  Since that table is
@@ -276,20 +279,20 @@ temacs:
 Type        Offset      Vaddr       Paddr
 Filesz      Memsz       Flags       Align
 
-6           0x34        0x8048034   0           
-0xa0        0xa0        5           0           
+6           0x34        0x8048034   0
+0xa0        0xa0        5           0
 
-3           0xd4        0           0           
-0x13        0           4           0           
+3           0xd4        0           0
+0x13        0           4           0
 
-1           0x34        0x8048034   0           
-0x3f2f9     0x3f2f9     5           0x1000      
+1           0x34        0x8048034   0
+0x3f2f9     0x3f2f9     5           0x1000
 
-1           0x3f330     0x8088330   0           
-0x215c4     0x25a60     7           0x1000      
+1           0x3f330     0x8088330   0
+0x215c4     0x25a60     7           0x1000
 
-2           0x60874     0x80a9874   0           
-0x80        0           7           0           
+2           0x60874     0x80a9874   0
+0x80        0           7           0
 
 raid:/nfs/raid/src/dist-18.56/src> dump -o xemacs
 
@@ -298,42 +301,42 @@ xemacs:
 Type        Offset      Vaddr       Paddr
 Filesz      Memsz       Flags       Align
 
-6           0x34        0x8048034   0           
-0xa0        0xa0        5           0           
+6           0x34        0x8048034   0
+0xa0        0xa0        5           0
 
-3           0xd4        0           0           
-0x13        0           4           0           
+3           0xd4        0           0
+0x13        0           4           0
 
-1           0x34        0x8048034   0           
-0x3f2f9     0x3f2f9     5           0x1000      
+1           0x34        0x8048034   0
+0x3f2f9     0x3f2f9     5           0x1000
 
-1           0x3f330     0x8088330   0           
-0x3e4d0     0x3e4d0     7           0x1000      
+1           0x3f330     0x8088330   0
+0x3e4d0     0x3e4d0     7           0x1000
 
-2           0x60874     0x80a9874   0           
-0x80        0           7           0           
+2           0x60874     0x80a9874   0
+0x80        0           7           0
 
 
  */
 
-/* Modified by wtien@urbana.mcd.mot.com of Motorola Inc. 
- * 
+/* Modified by wtien@urbana.mcd.mot.com of Motorola Inc.
+ *
  * The above mechanism does not work if the unexeced ELF file is being
- * re-layout by other applications (such as `strip'). All the applications 
+ * re-layout by other applications (such as `strip'). All the applications
  * that re-layout the internal of ELF will layout all sections in ascending
- * order of their file offsets. After the re-layout, the data2 section will 
- * still be the LAST section in the section header vector, but its file offset 
+ * order of their file offsets. After the re-layout, the data2 section will
+ * still be the LAST section in the section header vector, but its file offset
  * is now being pushed far away down, and causes part of it not to be mapped
- * in (ie. not covered by the load segment entry in PHDR vector), therefore 
+ * in (ie. not covered by the load segment entry in PHDR vector), therefore
  * causes the new binary to fail.
  *
  * The solution is to modify the unexec algorithm to insert the new data2
  * section header right before the new bss section header, so their file
- * offsets will be in the ascending order. Since some of the section's (all 
- * sections AFTER the bss section) indexes are now changed, we also need to 
- * modify some fields to make them point to the right sections. This is done 
+ * offsets will be in the ascending order. Since some of the section's (all
+ * sections AFTER the bss section) indexes are now changed, we also need to
+ * modify some fields to make them point to the right sections. This is done
  * by macro PATCH_INDEX. All the fields that need to be patched are:
- * 
+ *
  * 1. ELF header e_shstrndx field.
  * 2. section header sh_link and sh_info field.
  * 3. symbol table entry st_shndx field.
@@ -345,67 +348,67 @@ Filesz      Memsz       Flags       Alig
         Link    Info    Adralgn      Entsize
 
 [1]     1       2       0x80480d4    0xd4         0x13          .interp
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [2]     5       2       0x80480e8    0xe8         0x388         .hash
-        3       0       0x4          0x4          
+        3       0       0x4          0x4
 
 [3]     11      2       0x8048470    0x470        0x7f0         .dynsym
-        4       1       0x4          0x10         
+        4       1       0x4          0x10
 
 [4]     3       2       0x8048c60    0xc60        0x3ad         .dynstr
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [5]     9       2       0x8049010    0x1010       0x338         .rel.plt
-        3       7       0x4          0x8          
+        3       7       0x4          0x8
 
 [6]     1       6       0x8049348    0x1348       0x3           .init
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [7]     1       6       0x804934c    0x134c       0x680         .plt
-        0       0       0x4          0x4          
+        0       0       0x4          0x4
 
 [8]     1       6       0x80499cc    0x19cc       0x3c56f       .text
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [9]     1       6       0x8085f3c    0x3df3c      0x3           .fini
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [10]    1       2       0x8085f40    0x3df40      0x69c         .rodata
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [11]    1       2       0x80865dc    0x3e5dc      0xd51         .rodata1
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [12]    1       3       0x8088330    0x3f330      0x20afc       .data
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [13]    1       3       0x80a8e2c    0x5fe2c      0x89d         .data1
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [14]    1       3       0x80a96cc    0x606cc      0x1a8         .got
-        0       0       0x4          0x4          
+        0       0       0x4          0x4
 
 [15]    6       3       0x80a9874    0x60874      0x80          .dynamic
-        4       0       0x4          0x8          
+        4       0       0x4          0x8
 
 [16]    1       3       0x80a98f4    0x608f4      0x1cf0c       .data
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [17]    8       3       0x80c6800    0x7d800      0             .bss
-        0       0       0x4          0            
+        0       0       0x4          0
 
 [18]    2       0       0            0x7d800      0x9b90        .symtab
-        19      371     0x4          0x10         
+        19      371     0x4          0x10
 
 [19]    3       0       0            0x87390      0x8526        .strtab
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [20]    3       0       0            0x8f8b6      0x93          .shstrtab
-        0       0       0x1          0            
+        0       0       0x1          0
 
 [21]    1       0       0            0x8f949      0x68b7        .comment
-        0       0       0x1          0            
+        0       0       0x1          0
 
  */
 
@@ -417,15 +420,130 @@ Filesz      Memsz       Flags       Alig
 #include <errno.h>
 #include <unistd.h>
 #include <fcntl.h>
+#if !defined (__NetBSD__) && !defined (__OpenBSD__)
 #include <elf.h>
+#endif
 #include <sys/mman.h>
+#if defined (__sony_news) && defined (_SYSTYPE_SYSV)
+#include <sys/elf_mips.h>
+#include <sym.h>
+#endif /* __sony_news && _SYSTYPE_SYSV */
+
+#if defined (__alpha__) && !defined (__NetBSD__) && !defined (__OpenBSD__)
+/* Declare COFF debugging symbol table.  This used to be in
+   /usr/include/sym.h, but this file is no longer included in Red Hat
+   5.0 and presumably in any other glibc 2.x based distribution.  */
+typedef struct {
+	short magic;
+	short vstamp;
+	int ilineMax;
+	int idnMax;
+	int ipdMax;
+	int isymMax;
+	int ioptMax;
+	int iauxMax;
+	int issMax;
+	int issExtMax;
+	int ifdMax;
+	int crfd;
+	int iextMax;
+	long cbLine;
+	long cbLineOffset;
+	long cbDnOffset;
+	long cbPdOffset;
+	long cbSymOffset;
+	long cbOptOffset;
+	long cbAuxOffset;
+	long cbSsOffset;
+	long cbSsExtOffset;
+	long cbFdOffset;
+	long cbRfdOffset;
+	long cbExtOffset;
+} HDRR, *pHDRR; 
+#define cbHDRR sizeof(HDRR)
+#define hdrNil ((pHDRR)0)
+#endif
+
+#ifdef __NetBSD__
+/*
+ * NetBSD does not have normal-looking user-land ELF support.
+ */
+# ifdef __alpha__
+#  define ELFSIZE	64
+# else
+#  define ELFSIZE	32
+# endif
+# include <sys/exec_elf.h>
+
+#ifndef PT_LOAD
+# define PT_LOAD	Elf_pt_load
+# define SHT_SYMTAB	Elf_sht_symtab
+# define SHT_DYNSYM	Elf_sht_dynsym
+# define SHT_NULL	Elf_sht_null
+# define SHT_NOBITS	Elf_sht_nobits
+# define SHT_REL	Elf_sht_rel
+# define SHT_RELA	Elf_sht_rela
+
+# define SHN_UNDEF	Elf_eshn_undefined
+# define SHN_ABS	Elf_eshn_absolute
+# define SHN_COMMON	Elf_eshn_common
+#endif
+
+/*
+ * The magic of picking the right size types is handled by the ELFSIZE
+ * definition above.
+ */
+# ifdef __STDC__
+#  define ElfW(type)    Elf_##type
+# else
+#  define ElfW(type)    Elf_/**/type
+# endif
+
+# ifdef __alpha__
+#  include <sys/exec_ecoff.h>
+#  define HDRR		struct ecoff_symhdr
+#  define pHDRR		HDRR *
+# endif /* __alpha__*/
+
+# ifdef __mips__
+#  define SHT_MIPS_DEBUG	DT_MIPS_FLAGS
+#  define HDRR		struct Elf_Shdr
+# endif /* __mips__ */
+
+#endif /* __NetBSD__ */
+
+
+#ifdef __OpenBSD__
+# include <sys/exec_elf.h>
+#endif
+
+#if __GNU_LIBRARY__ - 0 >= 6
+# include <link.h>	/* get ElfW etc */
+#endif
+
+#ifndef ElfW
+# ifdef __STDC__
+#  define ElfW(type)	Elf32_##type
+# else
+#  define ElfW(type)	Elf32_/**/type
+# endif
+#endif
 
 #ifndef emacs
 #define fatal(a, b, c) fprintf (stderr, a, b, c), exit (1)
 #else
+#include <config.h>
 extern void fatal (char *, ...);
 #endif
 
+#if defined ( __sony_news) && defined (_SYSTYPE_SYSV)
+# define HAVE_MIPS_SBSS
+#endif
+
+#if (defined (__mips__) || defined (__powerpc__)) && (defined(__NetBSD__) || defined(__OpenBSD__))
+# define HAVE_MIPS_SBSS
+#endif
+
 #ifndef ELF_BSS_SECTION_NAME
 #define ELF_BSS_SECTION_NAME ".bss"
 #endif
@@ -433,15 +551,38 @@ extern void fatal (char *, ...);
 /* Get the address of a particular section or program header entry,
  * accounting for the size of the entries.
  */
+/* 
+   On PPC Reference Platform running Solaris 2.5.1
+   the plt section is also of type NOBI like the bss section.
+   (not really stored) and therefore sections after the bss
+   section start at the plt offset. The plt section is always
+   the one just before the bss section.
+   Thus, we modify the test from
+      if (NEW_SECTION_H (nn).sh_offset >= new_data2_offset)
+   to
+      if (NEW_SECTION_H (nn).sh_offset >= 
+               OLD_SECTION_H (old_bss_index-1).sh_offset)
+   This is just a hack. We should put the new data section
+   before the .plt section.
+   And we should not have this routine at all but use
+   the libelf library to read the old file and create the new
+   file.
+   The changed code is minimal and depends on prep set in m/prep.h
+   Erik Deumens
+   Quantum Theory Project
+   University of Florida
+   deumens@qtp.ufl.edu
+   Apr 23, 1996
+   */
 
 #define OLD_SECTION_H(n) \
-     (*(Elf32_Shdr *) ((byte *) old_section_h + old_file_h->e_shentsize * (n)))
+     (*(ElfW(Shdr) *) ((byte *) old_section_h + old_file_h->e_shentsize * (n)))
 #define NEW_SECTION_H(n) \
-     (*(Elf32_Shdr *) ((byte *) new_section_h + new_file_h->e_shentsize * (n)))
+     (*(ElfW(Shdr) *) ((byte *) new_section_h + new_file_h->e_shentsize * (n)))
 #define OLD_PROGRAM_H(n) \
-     (*(Elf32_Phdr *) ((byte *) old_program_h + old_file_h->e_phentsize * (n)))
+     (*(ElfW(Phdr) *) ((byte *) old_program_h + old_file_h->e_phentsize * (n)))
 #define NEW_PROGRAM_H(n) \
-     (*(Elf32_Phdr *) ((byte *) new_program_h + new_file_h->e_phentsize * (n)))
+     (*(ElfW(Phdr) *) ((byte *) new_program_h + new_file_h->e_phentsize * (n)))
 
 #define PATCH_INDEX(n) \
   do { \
@@ -451,9 +592,9 @@ typedef unsigned char byte;
 
 /* Round X up to a multiple of Y.  */
 
-int
+ElfW(Addr)
 round_up (x, y)
-     int x, y;
+     ElfW(Addr) x, y;
 {
   int rem = x % y;
   if (rem == 0)
@@ -461,6 +602,47 @@ round_up (x, y)
   return x - rem + y;
 }
 
+#if defined(__alpha__) || (defined ( __sony_news) && defined (_SYSTYPE_SYSV))
+/* We are using  ECOFF symbols embedded in ELF. */
+
+void
+relocate_ecoff_symhdr(symhdr, diff)
+    HDRR *symhdr;
+    ElfW(Word) diff;
+{
+  symhdr->cbLineOffset += diff;
+  symhdr->cbDnOffset   += diff;
+  symhdr->cbPdOffset   += diff;
+  symhdr->cbSymOffset  += diff;
+  symhdr->cbOptOffset  += diff;
+  symhdr->cbAuxOffset  += diff;
+  symhdr->cbSsOffset   += diff;
+  symhdr->cbSsExtOffset += diff;
+  symhdr->cbFdOffset   += diff;
+  symhdr->cbRfdOffset  += diff;
+  symhdr->cbExtOffset  += diff;
+}
+#endif /* __alpha__ or __sony_news and systype_sysv */
+
+#ifdef notyet
+void
+relocate_elf_proghdr(p, diff)
+    HDRR *symhdr;
+    ElfW(Word) diff;
+{
+	phdr->sh_name  += diff;
+	phdr->sh_type  += diff;
+	phdr->sh_flags += diff;
+	phdr->sh_addr  += diff;
+	phdr->sh_offset += diff;
+	phdr->sh_size  += diff;
+	phdr->sh_link  += diff;
+	phdr->sh_info  += diff;
+	phdr->sh_addralign += diff;
+	phdr->sh_entsize += diff;
+};
+#endif /* notyet */
+
 /* ****************************************************************
  * unexec
  *
@@ -483,19 +665,23 @@ unexec (new_name, old_name, data_start, 
   /* Pointers to the file, program and section headers for the old and new
    * files.
    */
-  Elf32_Ehdr *old_file_h, *new_file_h;
-  Elf32_Phdr *old_program_h, *new_program_h;
-  Elf32_Shdr *old_section_h, *new_section_h;
+  ElfW(Ehdr) *old_file_h, *new_file_h;
+  ElfW(Phdr) *old_program_h, *new_program_h;
+  ElfW(Shdr) *old_section_h, *new_section_h;
 
   /* Point to the section name table in the old file */
   char *old_section_names;
 
-  Elf32_Addr old_bss_addr, new_bss_addr;
-  Elf32_Word old_bss_size, new_data2_size;
-  Elf32_Off  new_data2_offset;
-  Elf32_Addr new_data2_addr;
+  ElfW(Addr) old_bss_addr, new_bss_addr;
+  ElfW(Word) old_bss_size, new_data2_size;
+  ElfW(Off)  new_data2_offset;
+  ElfW(Addr) new_data2_addr;
 
   int n, nn, old_bss_index, old_data_index, new_data2_index;
+#ifdef HAVE_MIPS_SBSS
+  int old_sbss_index, old_mdebug_index;
+  int bss_phdr_index;
+#endif /* HAVE_MIPS_SBSS */
   struct stat stat_buf;
 
   /* Open the old file & map it into the address space. */
@@ -508,7 +694,8 @@ unexec (new_name, old_name, data_start, 
   if (fstat (old_file, &stat_buf) == -1)
     fatal ("Can't fstat (%s): errno %d\n", old_name, errno);
 
-  old_base = mmap (0, stat_buf.st_size, PROT_READ, MAP_SHARED, old_file, 0);
+  old_base = mmap ((caddr_t) 0, stat_buf.st_size, PROT_READ, MAP_SHARED,
+		   old_file, 0);
 
   if (old_base == (caddr_t) -1)
     fatal ("Can't mmap (%s): errno %d\n", old_name, errno);
@@ -520,9 +707,9 @@ unexec (new_name, old_name, data_start, 
 
   /* Get pointers to headers & section names */
 
-  old_file_h = (Elf32_Ehdr *) old_base;
-  old_program_h = (Elf32_Phdr *) ((byte *) old_base + old_file_h->e_phoff);
-  old_section_h = (Elf32_Shdr *) ((byte *) old_base + old_file_h->e_shoff);
+  old_file_h = (ElfW(Ehdr) *) old_base;
+  old_program_h = (ElfW(Phdr) *) ((byte *) old_base + old_file_h->e_phoff);
+  old_section_h = (ElfW(Shdr) *) ((byte *) old_base + old_file_h->e_shoff);
   old_section_names = (char *) old_base
     + OLD_SECTION_H (old_file_h->e_shstrndx).sh_offset;
 
@@ -544,16 +731,61 @@ unexec (new_name, old_name, data_start, 
   if (old_bss_index == old_file_h->e_shnum)
     fatal ("Can't find .bss in %s.\n", old_name, 0);
 
+#ifdef HAVE_MIPS_SBSS
+  for (old_sbss_index = 1; old_sbss_index < (int) old_file_h->e_shnum;
+       old_sbss_index++)
+    {
+#ifdef DEBUG
+      fprintf (stderr, "Looking for .sbss - found %s\n",
+	       old_section_names + OLD_SECTION_H (old_sbss_index).sh_name);
+#endif
+      if (!strcmp (old_section_names + OLD_SECTION_H (old_sbss_index).sh_name,
+		   ".sbss"))
+	break;
+    }
+  if (old_sbss_index == old_file_h->e_shnum)
+    {
+      old_bss_addr = OLD_SECTION_H(old_bss_index).sh_addr;
+      old_bss_size = OLD_SECTION_H(old_bss_index).sh_size;
+      new_data2_offset = OLD_SECTION_H(old_bss_index).sh_offset;
+      new_data2_index = old_bss_index;
+    }
+  else
+    {
+      old_bss_addr = OLD_SECTION_H(old_sbss_index).sh_addr;
+      old_bss_size = OLD_SECTION_H(old_bss_index).sh_size
+	+ OLD_SECTION_H(old_sbss_index).sh_size;
+      new_data2_offset = OLD_SECTION_H(old_sbss_index).sh_offset;
+      new_data2_index = old_sbss_index;
+    }
+
+  for (old_mdebug_index = 1; old_mdebug_index < (int) old_file_h->e_shnum;
+       old_mdebug_index++)
+    {
+#ifdef DEBUG
+      fprintf (stderr, "Looking for .mdebug - found %s\n",
+	       old_section_names + OLD_SECTION_H (old_mdebug_index).sh_name);
+#endif
+      if (!strcmp (old_section_names + OLD_SECTION_H (old_mdebug_index).sh_name,
+		   ".mdebug"))
+	break;
+    }
+    if (old_mdebug_index == old_file_h->e_shnum)
+	old_mdebug_index = 0;
+#else /* not HAVE_MIPS_SBSS */
   old_bss_addr = OLD_SECTION_H (old_bss_index).sh_addr;
   old_bss_size = OLD_SECTION_H (old_bss_index).sh_size;
-#if defined(emacs) || !defined(DEBUG)
-  new_bss_addr = (Elf32_Addr) sbrk (0);
+#endif /* not HAVE_MIPS_SBSS */
+#if defined (emacs) || !defined (DEBUG)
+  new_bss_addr = (ElfW(Addr)) sbrk (0);
 #else
   new_bss_addr = old_bss_addr + old_bss_size + 0x1234;
 #endif
   new_data2_addr = old_bss_addr;
   new_data2_size = new_bss_addr - old_bss_addr;
+#ifndef HAVE_MIPS_SBSS
   new_data2_offset = OLD_SECTION_H (old_bss_index).sh_offset;
+#endif /*  not HAVE_MIPS_SBSS */
 
 #ifdef DEBUG
   fprintf (stderr, "old_bss_index %d\n", old_bss_index);
@@ -582,15 +814,20 @@ unexec (new_name, old_name, data_start, 
   if (ftruncate (new_file, new_file_size))
     fatal ("Can't ftruncate (%s): errno %d\n", new_name, errno);
 
-  new_base = mmap (0, new_file_size, PROT_READ | PROT_WRITE, MAP_SHARED,
-		   new_file, 0);
+#ifdef UNEXEC_USE_MAP_PRIVATE
+  new_base = mmap ((caddr_t) 0, new_file_size, PROT_READ | PROT_WRITE,
+		   MAP_PRIVATE, new_file, 0);
+#else
+  new_base = mmap ((caddr_t) 0, new_file_size, PROT_READ | PROT_WRITE,
+		   MAP_SHARED, new_file, 0);
+#endif
 
   if (new_base == (caddr_t) -1)
     fatal ("Can't mmap (%s): errno %d\n", new_name, errno);
 
-  new_file_h = (Elf32_Ehdr *) new_base;
-  new_program_h = (Elf32_Phdr *) ((byte *) new_base + old_file_h->e_phoff);
-  new_section_h = (Elf32_Shdr *)
+  new_file_h = (ElfW(Ehdr) *) new_base;
+  new_program_h = (ElfW(Phdr) *) ((byte *) new_base + old_file_h->e_phoff);
+  new_section_h = (ElfW(Shdr) *)
     ((byte *) new_base + old_file_h->e_shoff + new_data2_size);
 
   /* Make our new file, program and section headers as copies of the
@@ -633,8 +870,14 @@ unexec (new_name, old_name, data_start, 
       if ((OLD_SECTION_H (old_bss_index)).sh_addralign > alignment)
 	alignment = OLD_SECTION_H (old_bss_index).sh_addralign;
 
+#ifdef HAVE_MIPS_SBSS
+      if (NEW_PROGRAM_H (n).p_vaddr + NEW_PROGRAM_H (n).p_filesz
+	  > round_up (old_bss_addr, alignment))
+	fatal ("Program segment above .bss in %s\n", old_name, 0);
+#else /* not HAVE_MIPS_SBSS */
       if (NEW_PROGRAM_H (n).p_vaddr + NEW_PROGRAM_H (n).p_filesz > old_bss_addr)
 	fatal ("Program segment above .bss in %s\n", old_name, 0);
+#endif /* not HAVE_MIPS_SBSS */
 
       if (NEW_PROGRAM_H (n).p_type == PT_LOAD
 	  && (round_up ((NEW_PROGRAM_H (n)).p_vaddr
@@ -646,9 +889,16 @@ unexec (new_name, old_name, data_start, 
   if (n < 0)
     fatal ("Couldn't find segment next to .bss in %s\n", old_name, 0);
 
-  NEW_PROGRAM_H (n).p_filesz += new_data2_size;
+#ifdef HAVE_MIPS_SBSS
+  bss_phdr_index = n;
+#endif
+
+  /* Make sure that the size includes any padding before the old .bss
+     section.  */
+  NEW_PROGRAM_H (n).p_filesz = new_bss_addr - NEW_PROGRAM_H (n).p_vaddr;
   NEW_PROGRAM_H (n).p_memsz = NEW_PROGRAM_H (n).p_filesz;
 
+
 #if 0 /* Maybe allow section after data2 - does this ever happen? */
   for (n = new_file_h->e_phnum - 1; n >= 0; n--)
     {
@@ -675,18 +925,27 @@ unexec (new_name, old_name, data_start, 
   if (old_data_index == old_file_h->e_shnum)
     fatal ("Can't find .data in %s.\n", old_name, 0);
 
-  /* Walk through all section headers, insert the new data2 section right 
+  /* Walk through all section headers, insert the new data2 section right
      before the new bss section. */
   for (n = 1, nn = 1; n < (int) old_file_h->e_shnum; n++, nn++)
     {
       caddr_t src;
-      /* If it is bss section, insert the new data2 section before it. */
-      if (n == old_bss_index)
+      int temp_index;
+#ifdef HAVE_MIPS_SBSS
+      /* If it is (s)bss section, insert the new data2 section before it.  */
+      /* new_data2_index is the index of either old_sbss or old_bss, that was
+	 chosen as a section for new_data2.   */
+      temp_index = new_data2_index;
+#else /* not HAVE_MIPS_SBSS */
+      /* If it is bss section, insert the new data2 section before it.  */
+      temp_index = old_bss_index;
+#endif /* not HAVE_MIPS_SBSS */
+      if (n == temp_index)
 	{
 	  /* Steal the data section header for this data2 section. */
 	  memcpy (&NEW_SECTION_H (nn), &OLD_SECTION_H (old_data_index),
 		  new_file_h->e_shentsize);
-	  
+
 	  NEW_SECTION_H (nn).sh_addr = new_data2_addr;
 	  NEW_SECTION_H (nn).sh_offset = new_data2_offset;
 	  NEW_SECTION_H (nn).sh_size = new_data2_size;
@@ -696,37 +955,87 @@ unexec (new_name, old_name, data_start, 
 	  NEW_SECTION_H (nn).sh_addralign = OLD_SECTION_H (n).sh_addralign;
 
 	  /* Now copy over what we have in the memory now. */
-	  memcpy (NEW_SECTION_H (nn).sh_offset + new_base, 
-		  (caddr_t) OLD_SECTION_H (n).sh_addr, 
+	  memcpy (NEW_SECTION_H (nn).sh_offset + new_base,
+		  (caddr_t) OLD_SECTION_H (n).sh_addr,
 		  new_data2_size);
 	  nn++;
 	}
-      
-      memcpy (&NEW_SECTION_H (nn), &OLD_SECTION_H (n), 
+
+      memcpy (&NEW_SECTION_H (nn), &OLD_SECTION_H (n),
 	      old_file_h->e_shentsize);
       
-      /* The new bss section's size is zero, and its file offset and virtual
-	 address should be off by NEW_DATA2_SIZE. */
-      if (n == old_bss_index)
+      if (n == old_bss_index
+#ifdef HAVE_MIPS_SBSS
+	  /* The new bss and sbss section's size is zero, and its file offset
+	     and virtual address should be off by NEW_DATA2_SIZE.  */
+	  || n == old_sbss_index
+#endif /* HAVE_MIPS_SBSS */
+	  )
 	{
 	  /* NN should be `old_bss_index + 1' at this point. */
 	  NEW_SECTION_H (nn).sh_offset += new_data2_size;
 	  NEW_SECTION_H (nn).sh_addr += new_data2_size;
 	  /* Let the new bss section address alignment be the same as the
-	     section address alignment followed the old bss section, so 
+	     section address alignment followed the old bss section, so
 	     this section will be placed in exactly the same place. */
 	  NEW_SECTION_H (nn).sh_addralign = OLD_SECTION_H (nn).sh_addralign;
 	  NEW_SECTION_H (nn).sh_size = 0;
+
+#ifdef HAVE_MIPS_SBSS
+	  /* On ELF mips,  the new data section replaces both .sbss and .bss
+	     (we have, after all, written to them.).  Adding new_data2_size
+	     to the sh_addr and sh_offset of sbss puts sbss at the end of
+	     the new data section. setting the size to zero makes it empty.
+	     But then, adding the new_data2_size to the bss address puts
+	     its start  beyond the end of the original bss. If the sbss size
+	     was bigger than a page,  the bss ends up not covered by the
+	     program header.  This breaks strip. Since both sbss and bss
+	     are zero-sized,  just use the same address and file offset for
+	     both, guaranteeing other tools will assign them to the same
+	     program section (asssuming no sections are loaded at higher
+	     offsets.)  */
+	  if (n == old_bss_index) {
+	    	 int new_sbss_bss_padding = NEW_SECTION_H(nn).sh_addr -
+		    NEW_SECTION_H(nn - 1).sh_addr;
+		printf("sbss to bss offset =0x%x\n", new_sbss_bss_padding);
+		NEW_SECTION_H(nn).sh_addr =NEW_SECTION_H(nn - 1).sh_addr;
+		NEW_SECTION_H(nn).sh_offset =NEW_SECTION_H(nn - 1).sh_offset;
+	  }
+#endif  /* HAVE_MIPS_SBSS */
 	}
-      /* Any section that was original placed AFTER the bss section should now
-	 be off by NEW_DATA2_SIZE. */
-      else if (NEW_SECTION_H (nn).sh_offset >= new_data2_offset)
-	NEW_SECTION_H (nn).sh_offset += new_data2_size;
-      
+      else
+	{
+	  /* Any section that was original placed AFTER the bss
+	     section should now be off by NEW_DATA2_SIZE. */
+#ifdef SOLARIS_POWERPC
+	  /* On PPC Reference Platform running Solaris 2.5.1
+	     the plt section is also of type NOBI like the bss section.
+	     (not really stored) and therefore sections after the bss
+	     section start at the plt offset. The plt section is always
+	     the one just before the bss section.
+	     It would be better to put the new data section before
+	     the .plt section, or use libelf instead.
+	     Erik Deumens, deumens@qtp.ufl.edu.  */
+	  if (NEW_SECTION_H (nn).sh_offset
+	      >= OLD_SECTION_H (old_bss_index-1).sh_offset)
+	    NEW_SECTION_H (nn).sh_offset += new_data2_size;
+#else
+	  if (round_up (NEW_SECTION_H (nn).sh_offset,
+			OLD_SECTION_H (old_bss_index).sh_addralign)
+	      >= new_data2_offset)
+	    NEW_SECTION_H (nn).sh_offset += new_data2_size;
+#endif
+	  /* Any section that was originally placed after the section
+	     header table should now be off by the size of one section
+	     header table entry.  */
+	  if (NEW_SECTION_H (nn).sh_offset > new_file_h->e_shoff)
+	    NEW_SECTION_H (nn).sh_offset += new_file_h->e_shentsize;
+	}
+
       /* If any section hdr refers to the section after the new .data
-	 section, make it refer to next one because we have inserted 
+	 section, make it refer to next one because we have inserted
 	 a new section in between.  */
-      
+
       PATCH_INDEX (NEW_SECTION_H (nn).sh_link);
       /* For symbol tables, info is a symbol table index,
 	 so don't change it.  */
@@ -738,7 +1047,7 @@ unexec (new_name, old_name, data_start, 
       if (NEW_SECTION_H (nn).sh_type == SHT_NULL
 	  || NEW_SECTION_H (nn).sh_type == SHT_NOBITS)
 	continue;
-      
+
       /* Write out the sections. .data and .data1 (and data2, called
 	 ".data" in the strings table) get copied from the current process
 	 instead of the old file.  */
@@ -747,22 +1056,54 @@ unexec (new_name, old_name, data_start, 
 	  || !strcmp ((old_section_names + NEW_SECTION_H(n).sh_name),
 		      ".sdata")
 #endif
+#ifdef HAVE_MIPS_SBSS
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
+		      ".sdata")
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
+		      ".lit4")
+	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
+		      ".lit8")
+#endif /* HAVE_MIPS_SBSS */
 	  || !strcmp ((old_section_names + NEW_SECTION_H (n).sh_name),
 		      ".data1"))
 	src = (caddr_t) OLD_SECTION_H (n).sh_addr;
       else
 	src = old_base + OLD_SECTION_H (n).sh_offset;
-      
+
       memcpy (NEW_SECTION_H (nn).sh_offset + new_base, src,
 	      NEW_SECTION_H (nn).sh_size);
 
+#ifdef __alpha__
+      /* Update Alpha COFF symbol table: */
+      if (strcmp (old_section_names + OLD_SECTION_H (n).sh_name, ".mdebug")
+	  == 0)
+	{
+	  pHDRR symhdr = (pHDRR) (NEW_SECTION_H (nn).sh_offset + new_base);
+	  relocate_ecoff_symhdr(symhdr, new_data2_size);
+	}
+#endif /* __alpha__ */
+
+#if defined (__sony_news) && defined (_SYSTYPE_SYSV)
+      if (NEW_SECTION_H (nn).sh_type == SHT_MIPS_DEBUG && old_mdebug_index) 
+        {
+	  int diff = NEW_SECTION_H(nn).sh_offset 
+	 	- OLD_SECTION_H(old_mdebug_index).sh_offset;
+	  HDRR *phdr = (HDRR *)(NEW_SECTION_H (nn).sh_offset + new_base);
+
+	  if (diff)
+	    {
+	      relocate_ecoff_symhdr(phdr, diff);
+	    }
+	}
+#endif /* __sony_news and systype_sysv */
+
       /* If it is the symbol table, its st_shndx field needs to be patched.  */
       if (NEW_SECTION_H (nn).sh_type == SHT_SYMTAB
 	  || NEW_SECTION_H (nn).sh_type == SHT_DYNSYM)
 	{
-	  Elf32_Shdr *spt = &NEW_SECTION_H (nn);
+	  ElfW(Shdr) *spt = &NEW_SECTION_H (nn);
 	  unsigned int num = spt->sh_size / spt->sh_entsize;
-	  Elf32_Sym * sym = (Elf32_Sym *) (NEW_SECTION_H (nn).sh_offset + 
+	  ElfW(Sym) * sym = (ElfW(Sym) *) (NEW_SECTION_H (nn).sh_offset +
 					   new_base);
 	  for (; num--; sym++)
 	    {
@@ -770,7 +1111,7 @@ unexec (new_name, old_name, data_start, 
 		  || (sym->st_shndx == SHN_ABS)
 		  || (sym->st_shndx == SHN_COMMON))
 		continue;
-	
+
 	      PATCH_INDEX (sym->st_shndx);
 	    }
 	}
@@ -780,22 +1121,72 @@ unexec (new_name, old_name, data_start, 
   for (n = new_file_h->e_shnum - 1; n; n--)
     {
       byte *symnames;
-      Elf32_Sym *symp, *symendp;
+      ElfW(Sym) *symp, *symendp;
 
       if (NEW_SECTION_H (n).sh_type != SHT_DYNSYM
 	  && NEW_SECTION_H (n).sh_type != SHT_SYMTAB)
 	continue;
 
-      symnames = NEW_SECTION_H (NEW_SECTION_H (n).sh_link).sh_offset + new_base;
-      symp = (Elf32_Sym *) (NEW_SECTION_H (n).sh_offset + new_base);
-      symendp = (Elf32_Sym *) ((byte *)symp + NEW_SECTION_H (n).sh_size);
+      symnames = ((byte *) new_base
+		  + NEW_SECTION_H (NEW_SECTION_H (n).sh_link).sh_offset);
+      symp = (ElfW(Sym) *) (NEW_SECTION_H (n).sh_offset + new_base);
+      symendp = (ElfW(Sym) *) ((byte *)symp + NEW_SECTION_H (n).sh_size);
 
       for (; symp < symendp; symp ++)
 	if (strcmp ((char *) (symnames + symp->st_name), "_end") == 0
-	    || strcmp ((char *) (symnames + symp->st_name), "_edata") == 0)
+	    || strcmp ((char *) (symnames + symp->st_name), "end") == 0
+	    || strcmp ((char *) (symnames + symp->st_name), "_edata") == 0
+	    || strcmp ((char *) (symnames + symp->st_name), "edata") == 0)
 	  memcpy (&symp->st_value, &new_bss_addr, sizeof (new_bss_addr));
     }
 
+  /* This loop seeks out relocation sections for the data section, so
+     that it can undo relocations performed by the runtime linker.  */
+  for (n = new_file_h->e_shnum - 1; n; n--)
+    {
+      ElfW(Shdr) section = NEW_SECTION_H (n);
+      switch (section.sh_type) {
+      default:
+	break;
+      case SHT_REL:
+      case SHT_RELA:
+	/* This code handles two different size structs, but there should
+	   be no harm in that provided that r_offset is always the first
+	   member.  */
+	nn = section.sh_info;
+	if (!strcmp (old_section_names + NEW_SECTION_H (nn).sh_name, ".data")
+	    || !strcmp ((old_section_names + NEW_SECTION_H (nn).sh_name),
+			".data1"))
+	  {
+	    ElfW(Addr) offset = NEW_SECTION_H (nn).sh_addr -
+	      NEW_SECTION_H (nn).sh_offset;
+	    caddr_t reloc = old_base + section.sh_offset, end;
+	    for (end = reloc + section.sh_size; reloc < end;
+		 reloc += section.sh_entsize)
+	      {
+		ElfW(Addr) addr = ((ElfW(Rel) *) reloc)->r_offset - offset;
+#ifdef __alpha__
+		/* The Alpha ELF binutils currently have a bug that
+		   sometimes results in relocs that contain all
+		   zeroes.  Work around this for now...  */
+		if (((ElfW(Rel) *) reloc)->r_offset == 0)
+		    continue;
+#endif
+		memcpy (new_base + addr, old_base + addr, sizeof(ElfW(Addr)));
+	      }
+	  }
+	break;
+      }
+    }
+
+#ifdef UNEXEC_USE_MAP_PRIVATE
+  if (lseek (new_file, 0, SEEK_SET) == -1)
+    fatal ("Can't rewind (%s): errno %d\n", new_name, errno);
+
+  if (write (new_file, new_base, new_file_size) != new_file_size)
+    fatal ("Can't write (%s): errno %d\n", new_name, errno);
+#endif
+
   /* Close the files and make the new file executable.  */
 
   if (close (old_file))
