$NetBSD: patch-ae,v 1.5 2006/09/03 17:13:30 ben Exp $

--- main.c.orig	2001-03-25 19:44:50.000000000 -0800
+++ main.c
@@ -49,12 +49,18 @@
 #include <unistd.h>
 #include <string.h>
 #include <fcntl.h>
+#ifdef GETOPT_LONG
 #include <getopt.h>
+#endif
 #include <errno.h>
 #include <math.h>
 #include <sys/time.h>
 #include <sys/stat.h>
 
+#ifdef HAVE_GETRAWPARTITION
+#include <util.h>
+#endif
+
 #include "interface/cdda_interface.h"
 #include "paranoia/cdda_paranoia.h"
 #include "utils.h"
@@ -231,6 +237,7 @@ VERSION"\n"
 "  cdparanoia [options] <span> [outfile]\n\n"
 
 "OPTIONS:\n"
+#ifdef GETOPT_LONG
 "  -v --verbose                    : extra verbose operation\n"
 "  -q --quiet                      : quiet operation\n"
 "  -e --stderr-progress            : force output of progress information to\n"
@@ -256,9 +263,11 @@ VERSION"\n"
 "                                    to n sectors\n"
 "  -o --force-search-overlap  <n>  : force minimum overlap search during\n"
 "                                    verification to n sectors\n"
+#if !(defined(__APPLE__) && defined(__MACH__))
 "  -d --force-cdrom-device   <dev> : use specified device; disallow \n"
 "                                    autosense\n"
 "  -g --force-generic-device <dev> : use specified generic scsi device\n"
+#endif
 "  -S --force-read-speed <n>       : read from device at specified speed\n"
 "  -t --toc-offset <n>             : Add <n> sectors to the values reported\n"
 "                                    when addressing tracks. May be negative\n"
@@ -276,6 +285,52 @@ VERSION"\n"
 "  -Z --disable-paranoia           : disable all paranoia checking\n"
 "  -Y --disable-extra-paranoia     : only do cdda2wav-style overlap checking\n"
 "  -X --abort-on-skip              : abort on imperfect reads/skips\n\n"
+#else
+"  -v         : extra verbose operation\n"
+"  -q         : quiet operation\n"
+"  -e         : force output of progress information to\n"
+"               stderr (for wrapper scripts)\n"
+"  -V         : print version info and quit\n"
+"  -Q         : autosense drive, query disc and quit\n"
+"  -B         : 'batch' mode (saves each track to a seperate file.\n"
+"  -s         : do an exhaustive search for drive\n"
+"  -h         : print help\n\n"
+
+"  -p         : output raw 16 bit PCM in host byte order\n"
+"  -r         : output raw 16 bit little-endian PCM\n"
+"  -R         : output raw 16 bit big-endian PCM\n"
+"  -w         : output as WAV file (default)\n"
+"  -f         : output as AIFF file\n"
+"  -a         : output as AIFF-C file\n"
+"  -i <file>  : output human readable ripping info to file\n\n"
+
+"  -c         : force treating drive as little endian\n"
+"  -C         : force treating drive as big endian\n"
+"  -n <n>     : force default number of sectors in read to n sectors\n"
+"  -o <n>     : force minimum overlap search during\n"
+"               verification to n sectors\n"
+#if !(defined(__APPLE__) && defined(__MACH__))
+"  -d <dev>   : use specified device; disallow autosense\n"
+"  -g <dev>   : use specified generic scsi device\n"
+#endif
+"  -S <n>     : read from device at specified speed\n"
+"  -t <n>     : Add <n> sectors to the values reported\n"
+"               when addressing tracks. May be negative\n"
+"  -T         : Assume that the beginning offset of\n"
+"               track 1 as reported in the TOC will be\n"
+"               addressed as LBA 0.  Necessary for some\n"
+"               Toshiba drives to get track boundaries\n"
+"               correct\n"
+"  -O <n>     : Add <n> samples to the offset when\n"
+"               reading data.  May be negative.\n"
+"  -z[=n]     : never accept any less than perfect\n"
+"               data reconstruction (don't allow 'V's)\n"
+"               but if [n] is given, skip after [n]\n"
+"               retries without progress.\n"
+"  -Z         : disable all paranoia checking\n"
+"  -Y         : only do cdda2wav-style overlap checking\n"
+"  -X         : abort on imperfect reads/skips\n\n"
+#endif
 
 "OUTPUT SMILIES:\n"
 "  :-)   Normal operation, low/no jitter\n"
@@ -376,7 +431,7 @@ static void callback(long inpos, int fun
   int graph=30;
   char buffer[256];
   static long c_sector=0,v_sector=0;
-  static char dispcache[30]="                              ";
+  static char dispcache[30 + 1]="                              ";
   static int last=0;
   static long lasttime=0;
   long sector,osector=0;
@@ -587,6 +642,7 @@ static void callback(long inpos, int fun
 
 const char *optstring = "escCn:o:O:d:g:S:prRwafvqVQhZz::YXWBi:Tt:";
 
+#ifdef GETOPT_LONG
 struct option options [] = {
 	{"stderr-progress",no_argument,NULL,'e'},
 	{"search-for-drive",no_argument,NULL,'s'},
@@ -621,6 +677,7 @@ struct option options [] = {
 
 	{NULL,0,NULL,0}
 };
+#endif
 
 long blocking_write(int outf, char *buffer, long num){
   long words=0,temp;
@@ -673,7 +730,12 @@ int main(int argc,char *argv[]){
 
   atexit(cleanup);
 
-  while((c=getopt_long(argc,argv,optstring,options,&long_option_index))!=EOF){
+#ifdef GETOPT_LONG
+  while((c=getopt_long(argc,argv,optstring,options,&long_option_index))!=EOF)
+#else
+  while((c=getopt(argc,argv,optstring))!=EOF)
+#endif
+  {
     switch(c){
     case 'B':
       batch=1;
@@ -690,6 +752,7 @@ int main(int argc,char *argv[]){
     case 'o':
       force_cdrom_overlap=atoi(optarg);
       break;
+#if !(defined(__APPLE__) && defined(__MACH__))
     case 'd':
       if(force_cdrom_device)free(force_cdrom_device);
       force_cdrom_device=copystring(optarg);
@@ -698,6 +761,7 @@ int main(int argc,char *argv[]){
       if(force_generic_device)free(force_generic_device);
       force_generic_device=copystring(optarg);
       break;
+#endif
     case 'S':
       force_cdrom_speed=atoi(optarg);
       break;
@@ -811,6 +875,30 @@ int main(int argc,char *argv[]){
 
   /* Query the cdrom/disc; we may need to override some settings */
 
+#if defined(__APPLE__) && defined(__MACH__)
+  d=cdda_find_a_cdrom(verbose,NULL);
+#else
+#ifndef __linux__	/* XXX */
+#ifdef __NetBSD__
+  if (!force_generic_device) {
+    int raw;
+    static char devstring[16];
+#ifdef HAVE_GETRAWPARTITION
+    raw = getrawpartition();
+#else
+    raw = 'c' - 'a';
+#endif
+    snprintf(devstring, sizeof(devstring) - 1, "/dev/rcd0%c", raw + 'a');
+    force_generic_device=devstring;
+  }
+#else
+  if (!force_generic_device)
+    errx(1, "-g option is currently required by the NetBSD pkg version");
+#endif
+  if (!force_cdrom_device)
+    force_cdrom_device=copystring(force_generic_device);
+#endif
+
   if(force_generic_device)
     d=cdda_identify_scsi(force_generic_device,force_cdrom_device,verbose,NULL);
   else
@@ -841,6 +929,7 @@ int main(int argc,char *argv[]){
 	    report("");
 	}
       }
+#endif /* __APPLE__ && __DARWIN__ */
 
   if(!d){
     if(!verbose)
@@ -878,7 +967,9 @@ int main(int argc,char *argv[]){
 	      "ignoring preset and autosense",force_cdrom_sectors);
       report(buffer);
       d->nsectors=force_cdrom_sectors;
+#if !(defined(__APPLE__) && defined(__MACH__))
       d->bigbuff=force_cdrom_sectors*CD_FRAMESIZE_RAW;
+#endif
     }
   }
   if(force_cdrom_overlap!=-1){
